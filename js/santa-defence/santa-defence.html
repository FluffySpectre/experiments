<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"> 
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
        }

        .control-btn {
            border: 4px solid white;
            border-radius: 10px;
            width: 100px;
            height: 100px;
            position: absolute;
            bottom: 25px;
        }
        .control-btn.red {
            background: rgb(255, 0, 0);
            left: 438px;
        }
        .control-btn.green {
            background: rgb(0, 255, 0);
            left: 588px;
        }
        .control-btn.blue {
            background: rgb(0, 0, 255);
            left: 738px;
        }
    </style>
</head>

<body>
    <canvas id="game" width="1280" height="875"></canvas>

    <div class="control-btn red" onmousedown="controlButtonRed()"></div>
    <div class="control-btn green" onmousedown="controlButtonGreen()"></div>
    <div class="control-btn blue" onmousedown="controlButtonBlue()"></div>

    <script>
        // UTILITIES
        function rectContainsPoint(rx, ry, rw, rh, px, py) {
            return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
        }

        function rectContainsRect(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h) {
            return !(r2x > r1x + r1w || 
                r2x + r2w < r1x || 
                r2y > r1y + r1h ||
                r2y + r2h < r1x);
        }

        function rectContainsCircle(rx, ry, rw, rh, cx, cy, cr) {
            var distX = Math.abs(cx - rx - rw / 2);
            var distY = Math.abs(cy - ry - rh / 2);

            if (distX > (rw / 2 + cr)) { return false; }
            if (distY > (rh / 2 + cr)) { return false; }

            if (distX <= (rw / 2)) { return true; }
            if (distY <= (rh / 2)) { return true; }

            var dx = distX - rw / 2;
            var dy = distY - rh / 2;
            return (dx * dx + dy * dy <= (cr * cr));
        }

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min)) + min;
        }

        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        // CLASSES
        class Vector {
            constructor(x, y) {
                this.x = x || 0;
                this.y = y || 0;
            }

            add(v) {
                if (v instanceof Vector) {
                    this.x += v.x;
                    this.y += v.y;
                } else {
                    this.x += v;
                    this.y += v;
                }
                return this;
            }

            sub(v) {
                if (v instanceof Vector) {
                    this.x -= v.x;
                    this.y -= v.y;
                } else {
                    this.x -= v;
                    this.y -= v;
                }
                return this;
            }

            mult(v) {
                if (v instanceof Vector) {
                    this.x *= v.x;
                    this.y *= v.y;
                } else {
                    this.x *= v;
                    this.y *= v;
                }
                return this;
            }

            divide(v) {
                if (v instanceof Vector) {
                    if (v.x != 0) this.x /= v.x;
                    if (v.y != 0) this.y /= v.y;
                } else {
                    if (v != 0) {
                        this.x /= v;
                        this.y /= v;
                    }
                }
                return this;
            }

            normalize() {
                return this.divide(this.mag());
            }

            dot(v) {
                return this.x * v.x + this.y * v.y;
            }

            mag() {
                return Math.sqrt(this.dot(this));
            }

            setMag(newMag) {
                const currentMag = this.mag();
                this.x = this.x * newMag / currentMag;
                this.y = this.y * newMag / currentMag;
                return this;
            }

            copy() {
                return new Vector(this.x, this.y);
            }
        }

        class Player {
            constructor() {
                this.pos = new Vector(canvas.width / 2 - playerWidth / 2, canvas.height / 2 - playerHeight / 2);
                this.angle = 0;
                this.firing = -1;
                this.health = 10;
                this.noseColor = -1;
                this.resetNoseColorCounter = 2;
            }

            input(fire) {
                this.firing = fire;
            }

            update(dT) {
                if (this.noseColor > -1) {
                    this.resetNoseColorCounter -= dT;
                    if (this.resetNoseColorCounter < 0) {
                        this.noseColor = -1;
                        this.resetNoseColorCounter = 2;
                    }
                }
                
                // aim in the direction of the current mouse position
                this.angle = -Math.atan2(mouseInput.x - this.pos.x, mouseInput.y - this.pos.y) + Math.PI * 0.5;

                if (this.firing > -1) {
                    const impulse = new Impulse(this.pos.x - 145, this.pos.y - 22, this.firing);
                    impulse.vel = mouseInput.copy().sub(this.pos).normalize().mult(500);
                    impulses.push(impulse);

                    // set nose color to the current impulse color
                    this.noseColor = this.firing;
                    this.resetNoseColorCounter = 2;
                }
            }

            render() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.drawImage(santaImg, -santaImg.width * 1.25, -santaImg.height / 2);

                // draw colored nose
                ctx.beginPath();
                ctx.fillStyle = this.getNoseColor();
                ctx.arc(-132, -21, 5, 0, Math.PI * 2, true);
                ctx.fill();

                ctx.restore();
            }

            getNoseColor() {
                if (this.noseColor === -1) {
                    return 'rgb(255,0,0)';
                }
                const rgba = ['rgb(255,0,0)', 'rgb(0,255,0)', 'rgb(0,0,255)'];
                return rgba[this.noseColor];
            }
        }

        class Enemy {
            constructor(x, y, color) {
                this.pos = new Vector(x, y);
                this.vel = new Vector();
                this.remove = false;
                this.color = color;
                this.deathParticles = new ParticleSystem(new Vector(x, y));
                this.animateDeath = false;
                this.deathCounter = 3;
            }

            update(dT, impulses) {
                const vel = this.vel.copy().mult(dT);
                this.pos.add(vel);

                if (rectContainsRect(player.pos.x - playerWidth * 1.25, player.pos.y - playerHeight / 2, playerWidth, playerHeight, this.pos.x, this.pos.y, enemyWidth, enemyHeight)) {
                    player.health--;
                    if (player.health <= 0) {
                        player.health = 0;
                        gameOver = true;
                    }

                    this.remove = true;
                }

                for (let i of impulses) {
                    if (rectContainsCircle(this.pos.x, this.pos.y, enemyWidth, enemyHeight, i.pos.x, i.pos.y, i.radius())) {
                        i.remove = true;
                        if (this.color === i.color) {
                            this.remove = true;
                        }
                    }
                }

                if (this.remove) {
                    roundDestroyedEnemies++;
                    if (roundDestroyedEnemies === roundSpawns) {
                        roundSpawnedEnemies = 0;
                        roundDestroyedEnemies = 0;
                        roundSpawns += 5;

                        enemySpeed += 25;
                        spawnTime -= 0.25;

                        if (spawnTime < 0.5) spawnTime = 0.5;
                        if (enemySpeed > 500) enemySpeed = 500;

                        roundCooldown = 3;
                        round++;
                    }
                }
            }

            render() {
                ctx.fillStyle = this.getColor();
                ctx.fillRect(this.pos.x, this.pos.y, enemyWidth, enemyHeight);
            }

            getColor() {
                const rgba = ['rgb(255,0,0)', 'rgb(0,255,0)', 'rgb(0,0,255)'];
                return rgba[this.color];
            }
        }

        class Impulse {
            constructor(x, y, color) {
                this.pos = new Vector(x, y);
                this.vel = new Vector();
                this.remove = false;
                this.damage = 1;
                this.color = color;
                this.counter = 1.5;
                this.maxCounter = 1.5;
                this.angle = 0;
            }

            update(dT) {
                const vel = this.vel.copy().mult(dT);
                this.pos.add(vel);

                this.counter -= dT;

                const normalizedVel = vel.normalize();
                this.angle = -Math.atan2(normalizedVel.x, normalizedVel.y) + Math.PI * 0.5;

                if (!rectContainsPoint(0, 0, canvas.width, canvas.height, this.pos.x, this.pos.y)) {
                    this.remove = true;
                }
            }

            render() {
                ctx.save();
                ctx.fillStyle = this.getColor();
                ctx.beginPath();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle + Math.PI / 2);
                ctx.arc(0, 0, this.radius(), 0, Math.PI, true);
                ctx.fill();
                ctx.restore();
            }

            getColor() {
                const rgba = ['rgba(255,0,0,', 'rgba(0,255,0,', 'rgba(0,0,255,'];
                return rgba[this.color] + (this.counter / this.maxCounter) + ')';
            }

            radius() {
                return 120 * (this.maxCounter - this.counter + 0.075);
            }
        }

        class ParticleSystem {
            constructor(position) {
                this.origin = position.copy();
                this.particles = [];
            }
            
            addParticle(p) {
                this.particles.push(p);
            }

            run(dT) {
                for (let i = this.particles.length-1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.run(dT);
                    if (p.isDead()) {
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        class Particle {
            constructor(position) {
                this.acceleration = new Vector(0, 0.05);
                this.velocity = new Vector(getRandomFloat(-1, 1), getRandomFloat(-1, 0));
                this.position = position.copy();
                this.lifespan = 1.0;
            }
        
            run(dT) {
                this.update(dT);
                this.render();
            }

            update(dT) {
                this.velocity.add(this.acceleration).mult(dT);
                this.position.add(this.velocity).mult(dT);
                this.lifespan -= 0.02 * dT;
            }

            render() {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 12, 0, 2 * Math.PI, false);
                ctx.fillStyle = 'rgba(127, 127, 127, ' + this.lifespan + ')';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(200, 200, 200, ' + this.lifespan + ')';
                ctx.stroke();

                // stroke(200, this.lifespan);
                // strokeWeight(2);
                // fill(127, this.lifespan);
                // ellipse(this.position.x, this.position.y, 12, 12);
            }

            isDead() {
                if (this.lifespan < 0) {
                    return true;
                }
                return false;
            }
        }

        class SparkleParticle extends Particle {
            constructor(origin) {
                super(origin);

                this.theta = 0.0;
            }

            update(dT) {
                super.update(dT);
                
                this.theta += (this.velocity.x * this.velocity.mag()) / 10.0 * dT;
            }

            render() {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.theta);
                ctx.beginPath();
                ctx.moveTo(-3, 0);
                ctx.lineTo(3, 0);
                ctx.moveTo(0, -3);
                ctx.lineTo(0, 3);
                ctx.strokeStyle = 'rgba(255, 200, 0, ' + this.lifespan + ')';
                ctx.stroke();
                ctx.restore();
            }
        }

        // GLOBALS
        let canvas = document.getElementById('game');
        let ctx = canvas.getContext('2d');

        santaImg = new Image();
        santaImg.src = 'santa.png';
        santaImg.onload = function() {
            playerWidth = santaImg.width;
            playerHeight = santaImg.height;
        };
        starImg = new Image();
        starImg.src = 'star.png';

        let lastFrameTime = Date.now();
        let fireInput = 0, lastFireInput = -1;
        let mouseInput = new Vector(canvas.width, canvas.height / 2);
        const colors = ['lightgray', 'red', 'green', 'blue'];
        const enemyWidth = 80;
        const enemyHeight = 80;
        let playerWidth = 0;
        let playerHeight = 0;
        let player;
        let impulses = [];
        let enemies = [];
        let spawnTime = 3;
        let spawnCounter = 0;
        let gameOver = false;
        let worldPos = 0;
        let worldSpeed = 50;
        const controlBtnSize = 100;
        let roundSpawns = 5;
        let roundSpawnedEnemies = 0;
        let roundDestroyedEnemies = 0;
        let enemySpeed = 100;
        let roundCooldown = 3;
        let nextRound = 1;
        let round = 1;
        
        // setup stars for background
        let stars = [];
        for (let i = 0; i < 125; i++) {
            stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: getRandomInt(3, 32) });
        }

        function update() {
            // calculate frame time
            let deltaTime = (Date.now() - lastFrameTime) / 1000;
            lastFrameTime = Date.now();
            if (deltaTime > 1) deltaTime = 1;

            worldPos += worldSpeed * deltaTime;

            for (let s of stars) {
                s.x -= worldSpeed * deltaTime;
                if (s.x < -starImg.width) {
                    s.y = Math.random() * canvas.width;
                    s.x = canvas.width;
                    s.size = getRandomInt(3, 32)
                }
            }

            player.input(fireInput);
            player.update(deltaTime);

            for (let i of impulses) {
                i.update(deltaTime);
            }

            for (let e of enemies) {
                e.update(deltaTime, impulses);
            }

            // spawn enemies
            spawnCounter += deltaTime;
            roundCooldown -= deltaTime;

            if (roundCooldown <= 0 && spawnCounter > spawnTime && roundSpawnedEnemies < roundSpawns) {
                roundSpawnedEnemies++;
                spawnCounter = 0;

                const x = canvas.width + enemyWidth + 50;
                const y = canvas.height / 2 - enemyHeight / 2 - 25;
                const color = getRandomInt(0, 3);

                const enemy = new Enemy(x, y, color);
                enemy.vel = new Vector(-enemySpeed, 0);
                enemies.push(enemy);
            }

            // cleanup unneeded entities
            impulses = impulses.filter(i => !i.remove);
            enemies = enemies.filter(e => !e.remove);

            // reset inputs
            fireInput = -1;

            // at the end of each update cycle render the current state of the game
            render();
        }

        function render() {
            // clear screen
            ctx.fillStyle = '#182729';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // draw the star background
            ctx.fillStyle = 'white'; // TODO: maybe add some random transparency
            for (let s of stars) {
                ctx.drawImage(starImg, s.x, s.y, s.size, s.size);
            }

            player.render();

            for (let e of enemies) {
                e.render();
            }

            for (let i of impulses) {
                i.render();
            }

            // draw ui
            ctx.font = "32px Arial";
            ctx.fillStyle = 'white';
            ctx.fillText('VERBLEIBENDE GESCHENKE:', 0, 30);
            ctx.fillText('' + player.health, 480, 30);

            if (roundCooldown > 0) {
                ctx.font = "64px Arial";
                ctx.fillStyle = 'white';
                ctx.fillText('RUNDE ' + round, canvas.width / 2 - 110, canvas.height / 4);
            }
        }

        function restart() {
            player = new Player();

            enemies = [];
            fireInput = -1;
            lastFireInput = -1;

            gameOver = false;
        }

        // setup input handler
        document.addEventListener('keydown', (e) => {
            if (e.which === 37 || e.code === 'KeyA' && lastFireInput !== 0) controlButtonRed();
            if (e.which === 40 || e.code === 'KeyS' && lastFireInput !== 1) controlButtonGreen();
            if (e.which === 39 || e.code === 'KeyD' && lastFireInput !== 2) controlButtonBlue();
            if ((e.which === 32 || e.code === 'Space') && gameOver) {
                restart();
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.which === 37 || e.code === 'KeyA') {
                fireInput = -1;
                if (lastFireInput === 0) lastFireInput = -1;
            }
            if (e.which === 40 || e.code === 'KeyS') {
                fireInput = -1;
                if (lastFireInput === 1) lastFireInput = -1;
            }
            if (e.which === 39 || e.code === 'KeyD') {
                fireInput = -1;
                if (lastFireInput === 2) lastFireInput = -1;
            }
        });

        function controlButtonRed() {
            fireInput = 0;
            lastFireInput = 0;
        }
        function controlButtonGreen() {
            fireInput = 1;
            lastFireInput = 1;
        }
        function controlButtonBlue() {
            fireInput = 2;
            lastFireInput = 2;
        }
        

        restart();

        // setup draw loop
        setInterval(update, 1000 / 30);

    </script>
</body>

</html>